

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GPU programming example: stencil computation &mdash; GPU programming: why, when and how?  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_lesson.css?v=e9df6548" />
      <link rel="stylesheet" type="text/css" href="../_static/term_role_formatting.css?v=4194e21c" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_rtd_theme_ext_color_contrast.css?v=8e8ea19f" />
      <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=a5c4661c" />
      <link rel="stylesheet" type="text/css" href="../_static/overrides.css?v=eafd8254" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=187304be"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/minipres.js?v=a0d29692"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/tabs.js?v=3030b3cb"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Quick Reference" href="../quick-reference/" />
    <link rel="prev" title="Recommendations" href="../12-recommendations/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            GPU programming: why, when and how?
              <img src="../_static/ENCCS.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Prerequisites</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../0-setup/">Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The lesson</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1-gpu-history/">Why GPUs?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2-gpu-ecosystem/">The GPU hardware and software ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3-gpu-problems/">What problems fit to GPU?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4-gpu-concepts/">GPU programming concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5-intro-to-gpu-prog-models/">Introduction to GPU programming models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6-directive-based-models/">Directive-based models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7-non-portable-kernel-models/">Non-portable kernel-based models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8-portable-kernel-models/">Portable kernel-based models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../9-language-support/">High-level language support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-multiple_gpu/">Multiple GPU programming with MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11-gpu-porting/">Preparing code for GPU porting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12-recommendations/">Recommendations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">GPU programming example: stencil computation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#problem-heat-flow-in-two-dimensional-area">Problem: heat flow in two-dimensional area</a></li>
<li class="toctree-l2"><a class="reference internal" href="#technique-stencil-computation">Technique: stencil computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#technical-considerations">Technical considerations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sequential-and-thread-parallel-program-in-c">Sequential and thread-parallel program in C++</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpu-parallelization-timings">CPU parallelization: timings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gpu-parallelization-first-steps">GPU parallelization: first steps</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpu-parallelization-data-movement">GPU parallelization: data movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-jit-and-gpu-acceleration">Python: JIT and GPU acceleration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#julia-gpu-acceleration">Julia GPU acceleration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#see-also">See also</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick-reference/">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/lessons/">All lessons</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/">ENCCS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">GPU programming: why, when and how?</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">GPU programming example: stencil computation</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/gpu-programming/blob/main/content/13-examples.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="gpu-programming-example-stencil-computation">
<span id="example-heat"></span><h1>GPU programming example: stencil computation<a class="headerlink" href="#gpu-programming-example-stencil-computation" title="Link to this heading"></a></h1>
<div class="admonition-questions questions admonition" id="questions-0">
<p class="admonition-title">Questions</p>
<ul class="simple">
<li><p>How do I compile and run code developed using different programming models and frameworks?</p></li>
<li><p>What can I expect from the GPU-ported programs in terms of performance gains / trends and how do I estimate this?</p></li>
</ul>
</div>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<ul class="simple">
<li><p>To show a self-contained example of parallel computation executed on CPU and GPU using different programming models</p></li>
<li><p>To show differences and consequences of implementing the same algorithm in natural “style” of different models/ frameworks</p></li>
<li><p>To discuss how to assess theoretical and practical performance scaling of GPU codes</p></li>
</ul>
</div>
<div class="admonition-instructor-note instructor-note admonition" id="instructor-note-0">
<p class="admonition-title">Instructor note</p>
<ul class="simple">
<li><p>35 min teaching</p></li>
<li><p>30 min exercises</p></li>
</ul>
</div>
<section id="problem-heat-flow-in-two-dimensional-area">
<h2>Problem: heat flow in two-dimensional area<a class="headerlink" href="#problem-heat-flow-in-two-dimensional-area" title="Link to this heading"></a></h2>
<p>Heat flows in objects according to local temperature differences, as if seeking local
equilibrium. The following example defines a rectangular area with two always-warm sides
(temperature 70 and 85), two cold sides (temperature 20 and 5) and a cold disk at the
center. Because of heat diffusion, temperature of neighboring patches of the area is
bound to equalize, changing the overall distribution:</p>
<figure class="align-center" id="id1">
<img alt="../_images/heat_montage.png" src="../_images/heat_montage.png" />
<figcaption>
<p><span class="caption-text">Over time, the temperature distribution progresses from the initial state toward an
end state where upper triangle is warm and lower is cold. The average temperature
tends to (70 + 85 + 20 + 5) / 4 = 45.</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="technique-stencil-computation">
<h2>Technique: stencil computation<a class="headerlink" href="#technique-stencil-computation" title="Link to this heading"></a></h2>
<p>Heat transfer in the system above is governed by the partial differential equation(s)
describing local variation of the temperature field in time and space. That is, the rate
of change of the temperature field <span class="math notranslate nohighlight">\(u(x, y, t)\)</span> over two spatial dimensions
<span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and time <span class="math notranslate nohighlight">\(t\)</span> (with rate coefficient <span class="math notranslate nohighlight">\(\alpha\)</span>) can be
modelled via the equation</p>
<div class="math notranslate nohighlight">
\[\frac{\partial u}{\partial t} = \alpha \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right)\]</div>
<p>The standard way to numerically solve differential equations is to <em>discretize</em> them, i.
e. to consider only a set/ grid of specific area points at specific moments in time.
That way, partial derivatives <span class="math notranslate nohighlight">\({\partial u}\)</span> are converted into differences
between adjacent grid points <span class="math notranslate nohighlight">\(u^{m}(i,j)\)</span>, with <span class="math notranslate nohighlight">\(m, i, j\)</span> denoting time and
spatial grid points, respectively. Temperature change in time at a certain point can now
be computed from the values of neighboring points at earlier time; the same expression,
called <em>stencil</em>, is applied to every point on the grid.</p>
<figure class="align-center" id="id2">
<img alt="../_images/stencil.svg" src="../_images/stencil.svg" />
<figcaption>
<p><span class="caption-text">This simplified model uses an 8x8 grid of data in light blue in state <span class="math notranslate nohighlight">\(m\)</span>,
each location of which has to be updated based on the indicated 5-point stencil in
yellow to move to the next time point <span class="math notranslate nohighlight">\(m+1\)</span>.</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition-question-stencil-applications exercise important admonition" id="exercise-0">
<p class="admonition-title">Question: stencil applications</p>
<p>Stencil computation is a common occurrence in solving numerical problems. Have you already encountered it? Can you think of a problem that could be formulated this way in your field / area of expertise?</p>
<div class="admonition-solution solution important dropdown admonition" id="solution-0">
<p class="admonition-title">Solution</p>
<p>One obvious choice is <em>convolution</em> operation, used in image processing to apply various filter kernels; in some contexts, “convolution” and “stencil” are used almost interchangeably. Other related use is for averaging/ pooling adjacent values.</p>
</div>
</div>
<section id="technical-considerations">
<h3>Technical considerations<a class="headerlink" href="#technical-considerations" title="Link to this heading"></a></h3>
<p><strong>1. How fast and/ or accurate can the solution be?</strong></p>
<p>Spatial resolution of the temperature field is controlled by the number/ density of the
grid points. As the full grid update is required to proceed from one time point to the
next, stencil computation is the main target of parallelization (on CPU or GPU).</p>
<p>Moreover, in many cases the chosen time step cannot be arbitrarily large, otherwise the
numerical differentiation will fail, and dense/ accurate grids imply small time steps
(see inset below), which makes efficient spatial update even more important.</p>
<div class="admonition-optional-stencil-expression-and-time-step-limit solution important dropdown admonition" id="solution-1">
<p class="admonition-title">Optional: stencil expression and time-step limit</p>
<p>Differential equation shown above can be discretized using different schemes. For this example, temperature values at each grid point <span class="math notranslate nohighlight">\(u^{m}(i,j)\)</span> are updated from one time point (<span class="math notranslate nohighlight">\(m\)</span>) to the next (<span class="math notranslate nohighlight">\(m+1\)</span>), using the following expressions:</p>
<div class="math notranslate nohighlight">
\[u^{m+1}(i,j) = u^m(i,j) + \Delta t \alpha \nabla^2 u^m(i,j) ,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\nabla^2 u  &amp;= \frac{u(i-1,j)-2u(i,j)+u(i+1,j)}{(\Delta x)^2} \\
    &amp;+ \frac{u(i,j-1)-2u(i,j)+u(i,j+1)}{(\Delta y)^2} ,\end{split}\]</div>
<p>and <span class="math notranslate nohighlight">\(\Delta x\)</span>, <span class="math notranslate nohighlight">\(\Delta y\)</span>, <span class="math notranslate nohighlight">\(\Delta t\)</span> are step sizes in space and time, respectively.</p>
<p>Time-update schemes often have a limit on the maximum allowed time step <span class="math notranslate nohighlight">\(\Delta t\)</span>. For the current scheme, it is equal to</p>
<div class="math notranslate nohighlight">
\[\Delta t_{max} = \frac{(\Delta x)^2 (\Delta y)^2}{2 \alpha ((\Delta x)^2 + (\Delta y)^2)}\]</div>
</div>
<p><strong>2. What to do with area boundaries?</strong></p>
<p>Naturally, stencil expression can’t be applied directly to the outermost grid points
that have no outer neighbors. This can be solved by either changing the expression for
those points or by adding an additional layer of grid that is used in computing update,
but not updated itself – points of fixed temperature for the sides are being used in
this example.</p>
<p><strong>3. How could the algorithm be optimized further?</strong></p>
<p>In <a class="reference external" href="https://enccs.github.io/gpu-programming/7-non-portable-kernel-models/#memory-optimizations">an earlier episode</a>,
importance of efficient memory access was already stressed. In the following examples,
each grid point (and its neighbors) is treated mostly independently; however, this also
means that for 5-point stencil each value of the grid point may be read up to 5 times
from memory (even if it’s the fast GPU memory). By rearranging the order of mathematical
operations, it may be possible to reuse these values in a more efficient way.</p>
<p>Another point to note is that even if the solution is propagated in small time steps,
not every step might actually be needed for output. Once some <em>local</em> region of the
field is updated, mathematically nothing prevents it from being updated for the second
time step – even if the rest of the field is still being recalculated – as long as
<span class="math notranslate nohighlight">\(t = m-1\)</span> values for the region boundary are there when needed. (Of course, this
is more complicated to implement and would only give benefits in certain cases.)</p>
<div class="admonition-poll-which-programming-model-framework-are-you-most-interested-in-today exercise important admonition" id="exercise-1">
<p class="admonition-title">Poll: which programming model/ framework are you most interested in today?</p>
<ul class="simple">
<li><p>OpenMP offloading (C++)</p></li>
<li><p>SYCL (C++)</p></li>
<li><p><em>Python</em> (<code class="docutils literal notranslate"><span class="pre">numba</span></code>/CUDA)</p></li>
<li><p>Julia</p></li>
</ul>
</div>
<p>The following table will aid you in navigating the rest of this section:</p>
<div class="admonition-episode-guide admonition">
<p class="admonition-title">Episode guide</p>
<ul class="simple">
<li><p><a class="reference external" href="https://enccs.github.io/gpu-programming/13-examples/#sequential-and-thread-parallel-program-in-c">Sequential and OpenMP-threaded code</a>
in C++, including compilation/ running instructions</p></li>
<li><p><a class="reference external" href="https://enccs.github.io/gpu-programming/13-examples/#gpu-parallelization-first-steps">Naive GPU parallelization</a>,
including SYCL compilation instructions</p></li>
<li><p><a class="reference external" href="https://enccs.github.io/gpu-programming/13-examples/#gpu-parallelization-data-movement">GPU code with device data management</a>
(OpenMP, SYCL)</p></li>
<li><p><a class="reference external" href="https://enccs.github.io/gpu-programming/13-examples/#python-jit-and-gpu-acceleration">Python implementation</a>,
including running instructions on <a class="reference external" href="https://colab.research.google.com/">Google Colab</a></p></li>
<li><p><a class="reference external" href="https://enccs.github.io/gpu-programming/13-examples/#julia-gpu-acceleration">Julia implementation</a>,
including running instructions</p></li>
</ul>
</div>
</section>
</section>
<section id="sequential-and-thread-parallel-program-in-c">
<h2>Sequential and thread-parallel program in C++<a class="headerlink" href="#sequential-and-thread-parallel-program-in-c" title="Link to this heading"></a></h2>
<div class="admonition-trying-out-code-examples callout admonition" id="callout-0">
<p class="admonition-title">Trying out code examples</p>
<p>Source files of the examples presented for the rest of this episode are available in the <a class="reference external" href="https://github.com/ENCCS/gpu-programming/tree/main/content/examples/stencil/">content/examples/stencil/</a> directory.
To download them to your preferred directory on the cluster (f.e. <code class="docutils literal notranslate"><span class="pre">/scratch/project_&lt;#&gt;/&lt;your_folder&gt;/</span></code>), you can use Git:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ENCCS/gpu-programming.git
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>gpu-programming/content/examples/stencil/
<span class="gp">$ </span>ls
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Don’t forget to <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">pull</span></code> for the latest updates if you already have the content from the first day of the workshop!</p>
</div>
</div>
<p>If we assume the grid point values to be truly independent <em>for a single time step</em>,
stencil application procedure may be straightforwardly written as a loop over the grid
points, as shown below in tab “Stencil update”. (General structure of the program and
the default parameter values for the problem model are also provided for reference.)
CPU-thread parallelism can then be enabled by a single OpenMP <code class="docutils literal notranslate"><span class="pre">#pragma</span></code>:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-0-0-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-0-0-0" name="0-0" role="tab" tabindex="0">Stencil update</button><button aria-controls="panel-0-0-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-0-0-1" name="0-1" role="tab" tabindex="-1">Main function</button><button aria-controls="panel-0-0-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-0-0-2" name="0-2" role="tab" tabindex="-1">Default params</button></div><div aria-labelledby="tab-0-0-0" class="sphinx-tabs-panel" id="panel-0-0-0" name="0-0" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>

<span class="c1">// Update the temperature values using five-point stencil</span>
<span class="c1">// Arguments:</span>
<span class="c1">//   curr: current temperature values</span>
<span class="c1">//   prev: temperature values from previous time step</span>
<span class="c1">//   a: diffusivity</span>
<span class="c1">//   dt: time step</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">evolve</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Help the compiler avoid being confused by the structs</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Use OpenMP threads for parallel update of grid values</span>
<span class="hll"><span class="w">  </span><span class="cp">#pragma omp parallel for</span>
</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span>
<span class="w">	    </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">	     </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-0-0-1" class="sphinx-tabs-panel" hidden="true" id="panel-0-0-1" name="0-1" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Main routine for heat equation solver in 2D.</span>
<span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">start_time</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">stop_time</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Set up the solver</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span>
<span class="w">    </span><span class="n">field</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">previous</span><span class="p">;</span>
<span class="w">    </span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nsteps</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Output the initial field and its temperature</span>
<span class="w">    </span><span class="n">field_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">average_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field_average</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Average temperature, start: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">average_temp</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Set diffusivity constant</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Compute the largest stable time step</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dx</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dy</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy2</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// Set output interval</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">output_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1500</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Start timer</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">start_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_time</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Time evolution</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="w">        </span><span class="n">evolve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span>
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">output_interval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">field_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Swap current and previous fields for next iteration step</span>
<span class="w">        </span><span class="n">field_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Stop timer</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">stop_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stop_time</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Output the final field and its temperature</span>
<span class="w">    </span><span class="n">average_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field_average</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Average temperature at end: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">average_temp</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Compare temperature for reference</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Control temperature at end: 59.281239</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">field_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">nsteps</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Determine the computation time used for all the iterations</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Iterations took %.3f seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">stop_clock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_clock</span><span class="p">));</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-0-0-2" class="sphinx-tabs-panel" hidden="true" id="panel-0-0-2" name="0-2" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Datatype for temperature field</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">field</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// nx and ny are the dimensions of the field. The array data</span>
<span class="w">    </span><span class="c1">// contains also ghost layers, so it will have dimensions nx+2 x ny+2</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Size of the grid cells</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dx</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dy</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// The temperature values in the 2D grid</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// CONSTANTS</span>
<span class="c1">// Fixed grid spacing</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">DX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">DY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span>
<span class="c1">// Default temperatures</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">T_DISC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">T_AREA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">65.0</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">T_UPPER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">85.0</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">T_LOWER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">T_LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">T_RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">70.0</span><span class="p">;</span>
<span class="c1">// Default problem size</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ROWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">COLS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NSTEPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>
</pre></div>
</div>
</div></div>
<div class="admonition-optional-compiling-the-executables solution important dropdown admonition" id="solution-2">
<p class="admonition-title">Optional: compiling the executables</p>
<blockquote>
<div><p>To compile executable files for the OpenMP-based variants, follow the instructions below:</p>
</div></blockquote>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">salloc -A project_465001310 -p small-g -N 1 -c 8 -n 1 --gpus-per-node=1 -t 1:00:00</span>

<span class="go">module load LUMI/24.03</span>
<span class="go">module load partition/G</span>
<span class="go">module load rocm/6.0.3</span>
<span class="go">module load PrgEnv-cray/8.5.0</span>

<span class="go">cd base/</span>
<span class="go">make all</span>
</pre></div>
</div>
<p>Afterwards login into a compute node and test the executables (or just <code class="docutils literal notranslate"><span class="pre">srun</span> <span class="pre">&lt;executable&gt;</span></code> directly):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>srun<span class="w"> </span>--pty<span class="w"> </span>bash

<span class="gp">$ </span>./stencil
<span class="gp">$ </span>./stencil_off
<span class="gp">$ </span>./stencil_data

<span class="gp">$ </span><span class="nb">exit</span>
</pre></div>
</div>
<p>If everything works well, the output should look similar to this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./stencil
<span class="go">Average temperature, start: 59.763305</span>
<span class="go">Average temperature at end: 59.281239</span>
<span class="go">Control temperature at end: 59.281239</span>
<span class="go">Iterations took 0.566 seconds.</span>
<span class="gp">$ </span>./stencil_off
<span class="go">Average temperature, start: 59.763305</span>
<span class="go">Average temperature at end: 59.281239</span>
<span class="go">Control temperature at end: 59.281239</span>
<span class="go">Iterations took 3.792 seconds.</span>
<span class="gp">$ </span>./stencil_data
<span class="go">Average temperature, start: 59.763305</span>
<span class="go">Average temperature at end: 59.281239</span>
<span class="go">Control temperature at end: 59.281239</span>
<span class="go">Iterations took 1.211 seconds.</span>
<span class="gp">$</span>
</pre></div>
</div>
</div>
<section id="cpu-parallelization-timings">
<h3>CPU parallelization: timings<a class="headerlink" href="#cpu-parallelization-timings" title="Link to this heading"></a></h3>
<p>(<strong>NOTE</strong>: for thread-parallel runs it is necessary to request multiple CPU cores. In
LUMI-G partitions, this can be done by asking for multiple GPUs; an alternative is to
use -C partitions.)</p>
<p>For later comparison, some benchmarks of the OpenMP thread-parallel implementation are
provided below:</p>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text">Run times of OpenMP-enabled executable, s</span><a class="headerlink" href="#id3" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 33.3%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Job size</p></th>
<th class="head"><p>1 CPU core</p></th>
<th class="head"><p>32 CPU cores</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>S:2000 T:500</p></td>
<td><p>1.402</p></td>
<td><p>0.064</p></td>
</tr>
<tr class="row-odd"><td><p>S:2000 T:5000</p></td>
<td><p>13.895</p></td>
<td><p>0.538</p></td>
</tr>
<tr class="row-even"><td><p>S:2000 T:10000</p></td>
<td><p>27.753</p></td>
<td><p>1.071</p></td>
</tr>
<tr class="row-odd"><td><p>S:4000 T:500</p></td>
<td><p>5.727</p></td>
<td><p>0.633</p></td>
</tr>
<tr class="row-even"><td><p>S:8000 T:500</p></td>
<td><p>24.130</p></td>
<td><p>16.616</p></td>
</tr>
</tbody>
</table>
<p>A closer look reveals that the computation time scales very nicely with increasing
<strong>time steps</strong>:</p>
<figure class="align-center">
<img alt="../_images/omp-cpu-scaling-step.png" src="../_images/omp-cpu-scaling-step.png" />
</figure>
<p>However, for larger <strong>grid sizes</strong> the parallelization becomes inefficient – as the
individual chunks of the grid get too large to fit into CPU cache, threads become bound
by the speed of RAM reads/writes:</p>
<figure class="align-center">
<img alt="../_images/omp-cpu-scaling-grid.png" src="../_images/omp-cpu-scaling-grid.png" />
</figure>
<div class="admonition-discussion-heat-flow-computation-scaling exercise important admonition" id="exercise-2">
<p class="admonition-title">Discussion: heat flow computation scaling</p>
<ol class="arabic simple">
<li><p>How is heat flow computation <strong>expected</strong> to scale with respect to the number of time steps?</p>
<ol class="loweralpha simple">
<li><p>Linearly</p></li>
<li><p>Quadratically</p></li>
<li><p>Exponentially</p></li>
</ol>
</li>
<li><p>How is stencil application (grid update) <strong>expected</strong> to scale with respect to the size of the grid side?</p>
<ol class="loweralpha simple">
<li><p>Linearly</p></li>
<li><p>Quadratically</p></li>
<li><p>Exponentially</p></li>
</ol>
</li>
<li><p>(Optional) Do you expect GPU-accelerated computations to follow the above-mentioned trends? Why/ why not?</p></li>
</ol>
<div class="admonition-solution solution important dropdown admonition" id="solution-3">
<p class="admonition-title">Solution</p>
<ol class="arabic simple">
<li><p>The answer is a: since each time-step follows the previous one and involves a similar number of operations, then the update time per step will be more or less constant.</p></li>
<li><p>The answer is b: since stencil application is independent for every grid point, the update time will be proportional to the number of points, i.e. side * side.</p></li>
</ol>
</div>
</div>
</section>
</section>
<section id="gpu-parallelization-first-steps">
<h2>GPU parallelization: first steps<a class="headerlink" href="#gpu-parallelization-first-steps" title="Link to this heading"></a></h2>
<p>Let’s apply several techniques presented in previous episodes to make stencil update run
on GPU.</p>
<p>OpenMP (or OpenACC) offloading requires to define a region to be executed in parallel as
well as data that shall be copied over/ used in GPU memory. Similarly, SYCL programming
model offers convenient ways to define execution kernels, as well as context to run them
in (called queue).</p>
<p>Changes of stencil update code for OpenMP and SYCL are shown in the tabs below:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-1-1-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-1-1-0" name="1-0" role="tab" tabindex="0">OpenMP (naive)</button><button aria-controls="panel-1-1-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-1" name="1-1" role="tab" tabindex="-1">SYCL (naive)</button></div><div aria-labelledby="tab-1-1-0" class="sphinx-tabs-panel" id="panel-1-1-0" name="1-0" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>

<span class="c1">// Update the temperature values using five-point stencil</span>
<span class="c1">// Arguments:</span>
<span class="c1">//   curr: current temperature values</span>
<span class="c1">//   prev: temperature values from previous time step</span>
<span class="c1">//   a: diffusivity</span>
<span class="c1">//   dt: time step</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">evolve</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Help the compiler avoid being confused by the structs</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// Offload value update to GPU target (fallback to CPU is possible)</span>
<span class="hll"><span class="w">  </span><span class="cp">#pragma omp target teams distribute parallel for \</span>
</span><span class="hll"><span class="cp">  map(currdata[0:(nx+2)*(ny+2)],prevdata[0:(nx+2)*(ny+2)])</span>
</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span>
<span class="w">	    </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">	     </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-1-1-1" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-1" name="1-1" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sycl/sycl.hpp&gt;</span>

<span class="c1">// Update the temperature values using five-point stencil</span>
<span class="c1">// Arguments:</span>
<span class="c1">//   queue: SYCL queue</span>
<span class="c1">//   curr: current temperature values</span>
<span class="c1">//   prev: temperature values from previous time step</span>
<span class="c1">//   a: diffusivity</span>
<span class="c1">//   dt: time step</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">evolve</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Help the compiler avoid being confused by the structs</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>

<span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">malloc_device</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">malloc_device</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="hll"><span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">copy</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">currdata</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</span><span class="hll"><span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">copy</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">prevdata</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</span>
<span class="hll"><span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span>
<span class="w">      </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">       </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>

<span class="hll"><span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">copy</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">currdata</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">size</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
</span><span class="hll"><span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">currdata</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="hll"><span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">prevdata</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</div>
</div></div>
<div class="admonition-loading-sycl-modules-on-lumi callout admonition" id="callout-1">
<p class="admonition-title">Loading SYCL modules on LUMI</p>
<p>As SYCL is placed on top of ROCm/HIP (or CUDA) software stack, running SYCL executables may require respective modules to be loaded. On current nodes, it can be done as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>salloc<span class="w"> </span>-A<span class="w"> </span>project_465001310<span class="w"> </span>-p<span class="w"> </span>small-g<span class="w"> </span>-N<span class="w"> </span><span class="m">1</span><span class="w"> </span>-c<span class="w"> </span><span class="m">8</span><span class="w"> </span>-n<span class="w"> </span><span class="m">1</span><span class="w"> </span>--gpus-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>-t<span class="w"> </span><span class="m">1</span>:00:00

<span class="go">module load LUMI/24.03</span>
<span class="go">module load partition/G</span>
<span class="go">module load rocm/6.0.3</span>
<span class="go">module use  /appl/local/csc/modulefiles</span>
<span class="go">module load acpp/24.06.0</span>
</pre></div>
</div>
</div>
<div class="admonition-optional-compiling-the-sycl-executables solution important dropdown admonition" id="solution-4">
<p class="admonition-title">Optional: compiling the SYCL executables</p>
<p>As previously, you are welcome to generate your own executables:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>../sycl/
<span class="gp gp-VirtualEnv">(give the following lines some time, probably a couple of min)</span>
<span class="gp">$ </span>acpp<span class="w"> </span>-O2<span class="w"> </span>-o<span class="w"> </span>stencil_naive<span class="w"> </span>core-naive.cpp<span class="w"> </span>io.cpp<span class="w"> </span>main-naive.cpp<span class="w"> </span>pngwriter.c<span class="w"> </span>setup.cpp<span class="w"> </span>utilities.cpp
<span class="gp">$ </span>acpp<span class="w"> </span>-O2<span class="w"> </span>-o<span class="w"> </span>stencil<span class="w"> </span>core.cpp<span class="w"> </span>io.cpp<span class="w"> </span>main.cpp<span class="w"> </span>pngwriter.c<span class="w"> </span>setup.cpp<span class="w"> </span>utilities.cpp

<span class="gp">$ </span>srun<span class="w"> </span>stencil_naive
<span class="gp">$ </span>srun<span class="w"> </span>stencil
</pre></div>
</div>
<p>If everything works well, the output should look similar to this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>srun<span class="w"> </span>stencil_naive
<span class="go">Average temperature, start: 59.763305</span>
<span class="go">Average temperature at end: 59.281239</span>
<span class="go">Control temperature at end: 59.281239</span>
<span class="go">Iterations took 2.086 seconds.</span>
<span class="gp">$ </span>srun<span class="w"> </span>stencil
<span class="go">Average temperature, start: 59.763305</span>
<span class="go">Average temperature at end: 59.281239</span>
<span class="go">Control temperature at end: 59.281239</span>
<span class="go">Iterations took 0.052 seconds.</span>
</pre></div>
</div>
</div>
<div class="admonition-exercise-naive-gpu-ports exercise important admonition" id="exercise-3">
<p class="admonition-title">Exercise: naive GPU ports</p>
<p>Test your compiled executables <code class="docutils literal notranslate"><span class="pre">base/stencil</span></code>, <code class="docutils literal notranslate"><span class="pre">base/stencil_off</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl/stencil_naive</span></code>. Try changing problem size parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">srun</span> <span class="pre">stencil_naive</span> <span class="pre">2000</span> <span class="pre">2000</span> <span class="pre">5000</span></code></p></li>
</ul>
<p>Things to look for:</p>
<ul class="simple">
<li><p>How computation times change?</p></li>
<li><p>Do the results align to your expectations?</p></li>
</ul>
<div class="admonition-solution solution important dropdown admonition" id="solution-5">
<p class="admonition-title">Solution</p>
<p>You might notice that the GPU-“ported” versions actually run slower than the single-CPU-core version! In fact, the scaling behavior of all three variants is similar and expected, which is a good sign; only the “computation unit cost” is different. You can compare benchmark summaries in the tabs below:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-2-2-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-2-2-0" name="2-0" role="tab" tabindex="0">Sequential</button><button aria-controls="panel-2-2-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-2-2-1" name="2-1" role="tab" tabindex="-1">OpenMP (naive)</button><button aria-controls="panel-2-2-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-2-2-2" name="2-2" role="tab" tabindex="-1">SYCL (naive)</button></div><div aria-labelledby="tab-2-2-0" class="sphinx-tabs-panel" id="panel-2-2-0" name="2-0" role="tabpanel" tabindex="0"><figure class="align-center">
<img alt="../_images/cpu-seq-scaling.png" src="../_images/cpu-seq-scaling.png" />
</figure>
</div><div aria-labelledby="tab-2-2-1" class="sphinx-tabs-panel" hidden="true" id="panel-2-2-1" name="2-1" role="tabpanel" tabindex="0"><figure class="align-center">
<img alt="../_images/omp-gpu-naive-scaling.png" src="../_images/omp-gpu-naive-scaling.png" />
</figure>
</div><div aria-labelledby="tab-2-2-2" class="sphinx-tabs-panel" hidden="true" id="panel-2-2-2" name="2-2" role="tabpanel" tabindex="0"><figure class="align-center">
<img alt="../_images/omp-sycl-naive-scaling-new.png" src="../_images/omp-sycl-naive-scaling-new.png" />
</figure>
</div></div>
</div>
</div>
</section>
<section id="gpu-parallelization-data-movement">
<h2>GPU parallelization: data movement<a class="headerlink" href="#gpu-parallelization-data-movement" title="Link to this heading"></a></h2>
<p>Why the porting approach above seems to be quite inefficient?</p>
<p>On each step, we:</p>
<ul class="simple">
<li><p>re-allocate GPU memory,</p></li>
<li><p>copy the data from CPU to GPU,</p></li>
<li><p>perform the computation,</p></li>
<li><p>then copy the data back.</p></li>
</ul>
<p>But overhead can be reduced by taking care to minimize data transfers between <em>host</em> and
<em>device</em> memory:</p>
<ul class="simple">
<li><p>allocate GPU memory once at the start of the program,</p></li>
<li><p>only copy the data from GPU to CPU when we need it,</p></li>
<li><p>swap the GPU buffers between timesteps, like we do with CPU buffers. (OpenMP does this
automatically.)</p></li>
</ul>
<p>Changes of stencil update code as well as the main program are shown in tabs below.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-3-3-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-3-3-0" name="3-0" role="tab" tabindex="0">OpenMP</button><button aria-controls="panel-3-3-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-3-3-1" name="3-1" role="tab" tabindex="-1">SYCL</button><button aria-controls="panel-3-3-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-3-3-2" name="3-2" role="tab" tabindex="-1">Python</button><button aria-controls="panel-3-3-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-3-3-3" name="3-3" role="tab" tabindex="-1">main() (SYCL)</button></div><div aria-labelledby="tab-3-3-0" class="sphinx-tabs-panel" id="panel-3-3-0" name="3-0" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>

<span class="c1">// Update the temperature values using five-point stencil</span>
<span class="c1">// Arguments:</span>
<span class="c1">//   curr: current temperature values</span>
<span class="c1">//   prev: temperature values from previous time step</span>
<span class="c1">//   a: diffusivity</span>
<span class="c1">//   dt: time step</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">evolve</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Help the compiler avoid being confused by the structs</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// Offload value update to GPU target (fallback to CPU is possible)</span>
<span class="hll"><span class="w">  </span><span class="cp">#pragma omp target teams distribute parallel for</span>
</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span>
<span class="w">	    </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">	     </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="hll"><span class="c1">// Start a data region and copy temperature fields to the device</span>
</span><span class="hll"><span class="kt">void</span><span class="w"> </span><span class="nf">enter_data</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class="hll"><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
</span><span class="hll"><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="w">  </span><span class="c1">// adding data mapping here</span>
</span><span class="hll"><span class="w">  </span><span class="cp">#pragma omp target enter data \</span>
</span><span class="hll"><span class="cp">  map(to: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)])</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="c1">// End a data region and copy temperature fields back to the host</span>
</span><span class="hll"><span class="kt">void</span><span class="w"> </span><span class="nf">exit_data</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class="hll"><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
</span><span class="hll"><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="w">  </span><span class="c1">// adding data mapping here</span>
</span><span class="hll"><span class="w">  </span><span class="cp">#pragma omp target exit data \</span>
</span><span class="hll"><span class="cp">  map(from: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)])</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="c1">// Copy a temperature field from the device to the host</span>
</span><span class="hll"><span class="kt">void</span><span class="w"> </span><span class="nf">update_host</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">heat</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll"><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heat</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class="hll"><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heat</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
</span><span class="hll"><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heat</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="w">  </span><span class="c1">// adding data mapping here</span>
</span><span class="hll"><span class="w">  </span><span class="cp">#pragma omp target update from(data[0:(nx+2)*(ny+2)])</span>
</span><span class="hll"><span class="p">}</span>
</span></pre></div>
</div>
</div><div aria-labelledby="tab-3-3-1" class="sphinx-tabs-panel" hidden="true" id="panel-3-3-1" name="3-1" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sycl/sycl.hpp&gt;</span>

<span class="c1">// Update the temperature values using five-point stencil</span>
<span class="c1">// Arguments:</span>
<span class="c1">//   queue: SYCL queue</span>
<span class="c1">//   currdata: current temperature values (device pointer)</span>
<span class="c1">//   prevdata: temperature values from previous time step (device pointer)</span>
<span class="c1">//   prev: description of the grid parameters</span>
<span class="c1">//   a: diffusivity</span>
<span class="c1">//   dt: time step</span>
<span class="hll"><span class="kt">void</span><span class="w"> </span><span class="nf">evolve</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">currdata</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">,</span>
</span><span class="hll"><span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
</span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>

<span class="hll"><span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span>
<span class="w">      </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">       </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>

<span class="hll"><span class="kt">void</span><span class="w"> </span><span class="nf">copy_to_buffer</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">field</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</span><span class="hll"><span class="w">    </span><span class="n">Q</span><span class="p">.</span><span class="n">copy</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="kt">void</span><span class="w"> </span><span class="nf">copy_from_buffer</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</span><span class="hll"><span class="w">    </span><span class="n">Q</span><span class="p">.</span><span class="n">copy</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">size</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
</span><span class="hll"><span class="p">}</span>
</span></pre></div>
</div>
</div><div aria-labelledby="tab-3-3-2" class="sphinx-tabs-panel" hidden="true" id="panel-3-3-2" name="3-2" role="tabpanel" tabindex="0"><div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>

<span class="c1"># Update the temperature values using five-point stencil</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   curr: current temperature field object</span>
<span class="c1">#   prev: temperature field from previous time step</span>
<span class="c1">#   a: diffusivity</span>
<span class="c1">#   dt: time step</span>
<span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">dx2</span><span class="p">,</span> <span class="n">dy2</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">previous</span><span class="o">.</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">curr</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">previous</span><span class="o">.</span><span class="n">dev</span>
    <span class="c1"># Set thread and block sizes</span>
<span class="hll">    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># These are the FULL dims, rows+2 / cols+2</span>
</span><span class="hll">    <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>   <span class="c1"># Arbitrary choice</span>
</span><span class="hll">    <span class="n">bx</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="n">tx</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">ny</span> <span class="o">/</span> <span class="n">ty</span><span class="p">)</span>
</span>    <span class="c1"># Run numba (CUDA) kernel</span>
<span class="hll">    <span class="n">_evolve_kernel</span><span class="p">[(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">),</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">)](</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dx2</span><span class="p">,</span> <span class="n">dy2</span><span class="p">)</span>
</span>

<span class="nd">@cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_evolve_kernel</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dx2</span><span class="p">,</span> <span class="n">dy2</span><span class="p">):</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># These are the FULL dims, rows+2 / cols+2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span> \
            <span class="p">(</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx2</span> <span class="o">+</span> \
            <span class="p">(</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy2</span> <span class="p">)</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-3-3-3" class="sphinx-tabs-panel" hidden="true" id="panel-3-3-3" name="3-3" role="tabpanel" tabindex="0"><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Main routine for heat equation solver in 2D.</span>
<span class="c1">// (c) 2023 ENCCS, CSC and the contributors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sycl/sycl.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;chrono&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">wall_clock_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="p">;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;heat.h&quot;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">start_time</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">wall_clock_t</span><span class="o">::</span><span class="n">now</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">stop_time</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">wall_clock_t</span><span class="o">::</span><span class="n">now</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>


<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Set up the solver</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span>
<span class="w">    </span><span class="n">field</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">previous</span><span class="p">;</span>
<span class="w">    </span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nsteps</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Output the initial field and its temperature</span>
<span class="w">    </span><span class="n">field_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">average_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field_average</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Average temperature, start: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">average_temp</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Set diffusivity constant</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Compute the largest stable time step</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dx</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dy</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy2</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// Set output interval</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">output_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1500</span><span class="p">;</span>

<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">{</span><span class="n">sycl</span><span class="o">::</span><span class="n">property</span><span class="o">::</span><span class="n">queue</span><span class="o">::</span><span class="n">in_order</span><span class="p">()};</span>

<span class="w">    </span><span class="c1">// Create two identical device buffers</span>
<span class="hll"><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">d_current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">malloc_device</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">((</span><span class="n">current</span><span class="p">.</span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="hll"><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">d_previous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">malloc_device</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">((</span><span class="n">current</span><span class="p">.</span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span>
<span class="w">    </span><span class="c1">// Start timer</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">start_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_time</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Copy fields to device</span>
<span class="hll"><span class="w">    </span><span class="n">copy_to_buffer</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">d_previous</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">);</span>
</span><span class="hll"><span class="w">    </span><span class="n">copy_to_buffer</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">d_current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
</span><span class="w">    </span><span class="c1">// Time evolution</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">evolve</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">d_current</span><span class="p">,</span><span class="w"> </span><span class="n">d_previous</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">output_interval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Update data on host for output</span>
<span class="hll"><span class="w">            </span><span class="n">copy_from_buffer</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">d_current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
</span><span class="w">            </span><span class="n">field_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Swap current and previous fields for next iteration step</span>
<span class="w">        </span><span class="n">field_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">);</span>
<span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">d_current</span><span class="p">,</span><span class="w"> </span><span class="n">d_previous</span><span class="p">);</span>
</span><span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Copy data back to host</span>
<span class="hll"><span class="w">    </span><span class="n">copy_from_buffer</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">d_previous</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">);</span>
</span><span class="w">    </span><span class="c1">// Stop timer</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">stop_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stop_time</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Output the final field and its temperature</span>
<span class="w">    </span><span class="n">average_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field_average</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Average temperature at end: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">average_temp</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Compare temperature for reference</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Control temperature at end: 59.281239</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">field_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">nsteps</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Determine the computation time used for all the iterations</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">elapsed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stop_clock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_clock</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Iterations took %.3f seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">elapsed</span><span class="p">.</span><span class="n">count</span><span class="p">());</span>
<span class="hll"><span class="w">    </span><span class="n">Q</span><span class="p">.</span><span class="n">wait_and_throw</span><span class="p">();</span>
</span><span class="hll"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">d_previous</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="hll"><span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">d_current</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></div>
<div class="admonition-exercise-updated-gpu-ports exercise important admonition" id="exercise-4">
<p class="admonition-title">Exercise: updated GPU ports</p>
<p>Test your compiled executables <code class="docutils literal notranslate"><span class="pre">base/stencil_data</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl/stencil</span></code>. Try changing problem size parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">srun</span> <span class="pre">stencil</span> <span class="pre">2000</span> <span class="pre">2000</span> <span class="pre">5000</span></code></p></li>
</ul>
<p>Things to look for:</p>
<ul class="simple">
<li><p>How computation times change this time around?</p></li>
<li><p>What largest grid and/or longest propagation time can you get in 10 s on your machine?</p></li>
</ul>
<div class="admonition-solution solution important dropdown admonition" id="solution-6">
<p class="admonition-title">Solution</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-4-4-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-4-4-0" name="4-0" role="tab" tabindex="0">OpenMP data mapping</button><button aria-controls="panel-4-4-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-4-4-1" name="4-1" role="tab" tabindex="-1">SYCL device buffers</button></div><div aria-labelledby="tab-4-4-0" class="sphinx-tabs-panel" id="panel-4-4-0" name="4-0" role="tabpanel" tabindex="0"><p>Using GPU offloading with mapped device data, it is possible to achieve performance gains compared to thread-parallel version for larger grid sizes, due to the fact that the latter version becomes essentially RAM-bound, but the former does not.</p>
<figure class="align-center">
<img alt="../_images/omp-cpu-vs-gpu.png" src="../_images/omp-cpu-vs-gpu.png" />
</figure>
</div><div aria-labelledby="tab-4-4-1" class="sphinx-tabs-panel" hidden="true" id="panel-4-4-1" name="4-1" role="tabpanel" tabindex="0"><p>Below you can find the summary graphs for step- and grid- scaling of the stencil update task. Because of the more explicit programming approach, SYCL GPU port is much faster than OpenMP-offloaded version, comparable with thread-parallel CPU version running on all cores of a single node.</p>
<figure class="align-center">
<img alt="../_images/summary-scaling-step-new.png" src="../_images/summary-scaling-step-new.png" />
</figure>
<figure class="align-center">
<img alt="../_images/summary-scaling-grid-new.png" src="../_images/summary-scaling-grid-new.png" />
</figure>
</div></div>
</div>
</div>
</section>
<section id="python-jit-and-gpu-acceleration">
<h2>Python: JIT and GPU acceleration<a class="headerlink" href="#python-jit-and-gpu-acceleration" title="Link to this heading"></a></h2>
<p>As mentioned <a class="reference external" href="https://enccs.github.io/gpu-programming/9-language-support/#numba">previously</a>, Numba package
allows developers to just-in-time (JIT) compile Python code to run fast on CPUs, but can
also be used for JIT compiling for (NVIDIA) GPUs. JIT seems to work well on loop-based,
computationally heavy functions, so trying it out is a nice choice for initial source
version:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-5-5-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-5-5-0" name="5-0" role="tab" tabindex="0">Stencil update</button><button aria-controls="panel-5-5-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-5-5-1" name="5-1" role="tab" tabindex="-1">Data generation</button></div><div aria-labelledby="tab-5-5-0" class="sphinx-tabs-panel" id="panel-5-5-0" name="5-0" role="tabpanel" tabindex="0"><div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>


<span class="c1"># Update the temperature values using five-point stencil</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   curr: current temperature field object</span>
<span class="c1">#   prev: temperature field from previous time step</span>
<span class="c1">#   a: diffusivity</span>
<span class="c1">#   dt: time step</span>
<span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">dx2</span><span class="p">,</span> <span class="n">dy2</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">previous</span><span class="o">.</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">curr</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">previous</span><span class="o">.</span><span class="n">data</span>
    <span class="c1"># Run (possibly accelerated) update</span>
    <span class="n">_evolve</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dx2</span><span class="p">,</span> <span class="n">dy2</span><span class="p">)</span>


<span class="hll"><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span class="k">def</span> <span class="nf">_evolve</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dx2</span><span class="p">,</span> <span class="n">dy2</span><span class="p">):</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># These are the FULL dims, rows+2 / cols+2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span> \
              <span class="p">(</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx2</span> <span class="o">+</span> \
              <span class="p">(</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy2</span> <span class="p">)</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-5-5-1" class="sphinx-tabs-panel" hidden="true" id="panel-5-5-1" name="5-1" role="tabpanel" tabindex="0"><div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span class="k">def</span> <span class="nf">_generate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
    <span class="c1"># Radius of the source disc</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">/</span> <span class="mf">6.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
            <span class="c1"># Distance of point i, j from the origin</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">nx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">ny</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_DISC</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_AREA</span>

    <span class="c1"># Boundary conditions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_LEFT</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_RIGHT</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_UPPER</span>
        <span class="n">data</span><span class="p">[</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_LOWER</span>
</pre></div>
</div>
</div></div>
<p>The alternative approach would be to rewrite stencil update code in NumPy style,
exploiting loop vectorization.</p>
<div class="admonition-trying-out-python-examples callout admonition" id="callout-2">
<p class="admonition-title">Trying out Python examples</p>
<p>You can run provided code examples on Google Colab using instructions provided in the <a class="reference external" href="https://enccs.github.io/gpu-programming/0-setup/#running-on-google-colab">Setup</a>, your local machine, or LUMI node (non-GPU variants). On LUMI, you can set up Python distribution as following:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>module<span class="w"> </span>load<span class="w"> </span>cray-python/3.9.13.1
<span class="gp gp-VirtualEnv">(install needed dependencies locally)</span>
<span class="gp">$ </span>pip3<span class="w"> </span>install<span class="w"> </span>--user<span class="w"> </span>numba<span class="w"> </span>matplotlib
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>../python/
<span class="gp gp-VirtualEnv">(make sure you have active allocation)</span>
<span class="gp">$ </span>srun<span class="w"> </span>python3<span class="w"> </span>main.py
</pre></div>
</div>
</div>
<p>Short summary of a typical Colab run is provided below:</p>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text">Run times of Numba JIT-enabled Python program, s</span><a class="headerlink" href="#id4" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Job size</p></th>
<th class="head"><p>JIT (LUMI)</p></th>
<th class="head"><p>JIT (Colab)</p></th>
<th class="head"><p>Job size</p></th>
<th class="head"><p>no JIT (Colab)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>S:2000 T:500</p></td>
<td><p>1.648</p></td>
<td><p>8.495</p></td>
<td><p>S:200 T:50</p></td>
<td><p>5.318</p></td>
</tr>
<tr class="row-odd"><td><p>S:2000 T:200</p></td>
<td><p>0.787</p></td>
<td><p>3.524</p></td>
<td><p>S:200 T:20</p></td>
<td><p>1.859</p></td>
</tr>
<tr class="row-even"><td><p>S:1000 T:500</p></td>
<td><p>0.547</p></td>
<td><p>2.230</p></td>
<td><p>S:100 T:50</p></td>
<td><p>1.156</p></td>
</tr>
</tbody>
</table>
<p>Numba’s <code class="docutils literal notranslate"><span class="pre">&#64;vectorize</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;guvectorize</span></code> decorators offer an interface to create CPU-
(or GPU-) accelerated <em>Python</em> functions without explicit implementation details.
However, such functions become increasingly complicated to write (and optimize by the
compiler) with increasing complexity of the computations within.</p>
<p>Numba also offers direct CUDA-based kernel programming, which can be the best choice for
those already familiar with CUDA. Example for stencil update written in Numba CUDA is
shown in the <a class="reference external" href="https://enccs.github.io/gpu-programming/13-examples/#gpu-parallelization-data-movement">data movement section</a>,
tab “Python”. In this case, data transfer functions <code class="docutils literal notranslate"><span class="pre">devdata</span> <span class="pre">=</span> <span class="pre">cuda.to_device(data)</span></code>
and <code class="docutils literal notranslate"><span class="pre">devdata.copy_to_host(data)</span></code> (see <code class="docutils literal notranslate"><span class="pre">main_cuda.py</span></code>) are already provided by Numba
package.</p>
<div class="admonition-exercise-cuda-acceleration-in-python exercise important admonition" id="exercise-5">
<p class="admonition-title">Exercise: CUDA acceleration in Python</p>
<p>Using Google Colab (or your own machine), run provided Numba-CUDA Python program. Try changing problem size parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">args.rows,</span> <span class="pre">args.cols,</span> <span class="pre">args.nsteps</span> <span class="pre">=</span> <span class="pre">2000,</span> <span class="pre">2000,</span> <span class="pre">5000</span></code> for notebooks,</p></li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">srun</span></code>] <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">main.py</span> <span class="pre">2000</span> <span class="pre">2000</span> <span class="pre">5000</span></code> for command line.</p></li>
</ul>
<p>Things to look for:</p>
<ul class="simple">
<li><p>How computation times change?</p></li>
<li><p>Do you get better performance than from JIT-compiled CPU version? How far can you push the problem size?</p></li>
<li><p>Are you able to monitor the GPU usage?</p></li>
</ul>
<div class="admonition-solution solution important dropdown admonition" id="solution-7">
<p class="admonition-title">Solution</p>
<p>Some numbers from Colab:</p>
<table class="docutils align-default" id="id5">
<caption><span class="caption-text">Run times of Numba CUDA Python program, s</span><a class="headerlink" href="#id5" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Job size</p></th>
<th class="head"><p>JIT (LUMI)</p></th>
<th class="head"><p>JIT (Colab)</p></th>
<th class="head"><p>CUDA (Colab)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>S:2000 T:500</p></td>
<td><p>1.648</p></td>
<td><p>8.495</p></td>
<td><p>1.079</p></td>
</tr>
<tr class="row-odd"><td><p>S:2000 T:2000</p></td>
<td><p>6.133</p></td>
<td><p>36.61</p></td>
<td><p>3.931</p></td>
</tr>
<tr class="row-even"><td><p>S:5000 T:500</p></td>
<td><p>9.478</p></td>
<td><p>57.19</p></td>
<td><p>6.448</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section id="julia-gpu-acceleration">
<h2>Julia GPU acceleration<a class="headerlink" href="#julia-gpu-acceleration" title="Link to this heading"></a></h2>
<p>A Julia version of the stencil example above can be found below (a simplified version of
the HeatEquation module at <a class="reference external" href="https://github.com/ENCCS/HeatEquation.jl">https://github.com/ENCCS/HeatEquation.jl</a>). The source files
are also available in the <a class="reference external" href="https://github.com/ENCCS/gpu-programming/tree/main/content/examples/stencil/julia">content/examples/stencil/julia</a>
directory of this repository.</p>
<p>To run the example on LUMI CPU partition, type:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="c1"># interactive CPU node</span>
<span class="gp">$ </span>srun<span class="w"> </span>--account<span class="o">=</span>project_465001310<span class="w"> </span>--partition<span class="o">=</span>standard<span class="w"> </span>--nodes<span class="o">=</span><span class="m">1</span><span class="w"> </span>--cpus-per-task<span class="o">=</span><span class="m">32</span><span class="w"> </span>--ntasks-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">01</span>:00:00<span class="w"> </span>--pty<span class="w"> </span>bash
<span class="gp">$ </span><span class="c1"># load Julia env</span>
<span class="gp">$ </span>module<span class="w"> </span>purge
<span class="gp">$ </span>module<span class="w"> </span>use<span class="w"> </span>/appl/local/csc/modulefiles
<span class="gp">$ </span>module<span class="w"> </span>load<span class="w"> </span>julia/1.9.0
<span class="gp">$ </span><span class="c1"># in directory with Project.toml and source files, instantiate an environment to install packages</span>
<span class="gp">$ </span>julia<span class="w"> </span>--project<span class="w"> </span>-e<span class="w"> </span><span class="s2">&quot;using Pkg ; Pkg.instantiate()&quot;</span>
<span class="gp">$ </span><span class="c1"># finally run</span>
<span class="gp">$ </span>julia<span class="w"> </span>--project<span class="w"> </span>main.jl
</pre></div>
</div>
<p>To run on the GPU partition, use instead the <code class="docutils literal notranslate"><span class="pre">srun</span></code> command</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>srun<span class="w"> </span>--account<span class="o">=</span>project_465001310<span class="w"> </span>--partition<span class="o">=</span>standard-g<span class="w"> </span>--nodes<span class="o">=</span><span class="m">1</span><span class="w"> </span>--cpus-per-task<span class="o">=</span><span class="m">1</span><span class="w"> </span>--ntasks-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>--gpus-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">1</span>:00:00<span class="w"> </span>--pty<span class="w"> </span>bash
</pre></div>
</div>
<div class="admonition-optional-dependency callout admonition" id="callout-3">
<p class="admonition-title">Optional dependency</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">Plots.jl</span></code> dependency is commented out in <code class="docutils literal notranslate"><span class="pre">main.jl</span></code> and <code class="docutils literal notranslate"><span class="pre">Project.toml</span></code>. This saves ~2 minute precompilation time when you first instantiate the Julia environment. To generate plots, just uncomment the commented <code class="docutils literal notranslate"><span class="pre">Plots.jl</span></code> dependency in <code class="docutils literal notranslate"><span class="pre">Project.toml</span></code>, instantiate again, and import and use <code class="docutils literal notranslate"><span class="pre">Plots</span></code> in <code class="docutils literal notranslate"><span class="pre">main.jl</span></code>.</p>
</div>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-6-6-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-6-6-0" name="6-0" role="tab" tabindex="0">main.jl</button><button aria-controls="panel-6-6-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-6-6-1" name="6-1" role="tab" tabindex="-1">core.jl</button><button aria-controls="panel-6-6-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-6-6-2" name="6-2" role="tab" tabindex="-1">heat.jl</button><button aria-controls="panel-6-6-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-6-6-3" name="6-3" role="tab" tabindex="-1">Project.toml</button></div><div aria-labelledby="tab-6-6-0" class="sphinx-tabs-panel" id="panel-6-6-0" name="6-0" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c">#using Plots</span>
<span class="k">using</span><span class="w"> </span><span class="n">BenchmarkTools</span>

<span class="n">include</span><span class="p">(</span><span class="s">&quot;heat.jl&quot;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s">&quot;core.jl&quot;</span><span class="p">)</span>


<span class="s">&quot;&quot;&quot;</span>
<span class="s">    visualize(curr::Field, filename=:none)</span>

<span class="s">Create a heatmap of a temperature field. Optionally write png file. </span>
<span class="s">&quot;&quot;&quot;</span><span class="w">    </span>
<span class="k">function</span><span class="w"> </span><span class="n">visualize</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="o">=</span><span class="ss">:none</span><span class="p">)</span>
<span class="w">    </span><span class="n">background_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:white</span>
<span class="w">    </span><span class="n">plot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heatmap</span><span class="p">(</span>
<span class="w">        </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
<span class="w">        </span><span class="n">colorbar_title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Temperature (C)&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">background_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">background_color</span>
<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="ss">:none</span>
<span class="w">        </span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">display</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>


<span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">nrows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2048</span><span class="p">,</span><span class="w"> </span><span class="mi">2048</span>
<span class="n">nsteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span>

<span class="c"># initialize current and previous states to the same state</span>
<span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize</span><span class="p">(</span><span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">nrows</span><span class="p">)</span>

<span class="c"># visualize initial field, requires Plots.jl</span>
<span class="c">#visualize(curr, &quot;initial.png&quot;)</span>

<span class="c"># simulate temperature evolution for nsteps</span>
<span class="n">simulate!</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">nsteps</span><span class="p">)</span>

<span class="c"># visualize final field, requires Plots.jl</span>
<span class="c">#visualize(curr, &quot;final.png&quot;)</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-6-6-1" class="sphinx-tabs-panel" hidden="true" id="panel-6-6-1" name="6-1" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ProgressMeter</span>

<span class="s">&quot;&quot;&quot;</span>
<span class="s">    evolve!(curr::Field, prev::Field, a, dt)</span>

<span class="s">Calculate a new temperature field curr based on the previous </span>
<span class="s">field prev. a is the diffusion constant and dt is the largest </span>
<span class="s">stable time step.    </span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="w"> </span><span class="n">evolve!</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="w">    </span><span class="n">Threads</span><span class="o">.</span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">curr</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">curr</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">xderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">yderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">xderiv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yderiv</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>



<span class="s">&quot;&quot;&quot;</span>
<span class="s">    swap_fields!(curr::Field, prev::Field)</span>

<span class="s">Swap the data of two fields curr and prev.    </span>
<span class="s">&quot;&quot;&quot;</span><span class="w">    </span>
<span class="k">function</span><span class="w"> </span><span class="n">swap_fields!</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">::</span><span class="kt">Field</span><span class="p">)</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span>
<span class="w">    </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span>
<span class="w">    </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span>
<span class="k">end</span>

<span class="s">&quot;&quot;&quot; </span>
<span class="s">    average_temperature(f::Field)</span>

<span class="s">Calculate average temperature of a temperature field.        </span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">average_temperature</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">Field</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>

<span class="s">&quot;&quot;&quot;</span>
<span class="s">    simulate!(current, previous, nsteps)</span>

<span class="s">Run the heat equation solver on fields curr and prev for nsteps.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="w"> </span><span class="n">simulate!</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">nsteps</span><span class="p">)</span>

<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Initial average temperature: </span><span class="si">$</span><span class="p">(</span><span class="n">average_temperature</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span><span class="s">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Diffusion constant</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span>
<span class="w">    </span><span class="c"># Largest stable time step</span>
<span class="w">    </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span>
<span class="w">    </span>
<span class="w">    </span><span class="c"># display a nice progress bar</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Progress</span><span class="p">(</span><span class="n">nsteps</span><span class="p">)</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">nsteps</span>
<span class="w">        </span><span class="c"># calculate new state based on previous state</span>
<span class="w">        </span><span class="n">evolve!</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>

<span class="w">        </span><span class="c"># swap current and previous fields</span>
<span class="w">        </span><span class="n">swap_fields!</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">)</span>

<span class="w">        </span><span class="c"># increment the progress bar</span>
<span class="w">        </span><span class="n">next!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span>

<span class="w">    </span><span class="c"># print final average temperature</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Final average temperature: </span><span class="si">$</span><span class="p">(</span><span class="n">average_temperature</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-6-6-2" class="sphinx-tabs-panel" hidden="true" id="panel-6-6-2" name="6-2" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># Fixed grid spacing</span>
<span class="k">const</span><span class="w"> </span><span class="n">DX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span>
<span class="k">const</span><span class="w"> </span><span class="n">DY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span>
<span class="c"># Default temperatures</span>
<span class="k">const</span><span class="w"> </span><span class="n">T_DISC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span>
<span class="k">const</span><span class="w"> </span><span class="n">T_AREA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">65.0</span>
<span class="k">const</span><span class="w"> </span><span class="n">T_UPPER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">85.0</span>
<span class="k">const</span><span class="w"> </span><span class="n">T_LOWER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span>
<span class="k">const</span><span class="w"> </span><span class="n">T_LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0</span>
<span class="k">const</span><span class="w"> </span><span class="n">T_RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">70.0</span>
<span class="c"># Default problem size</span>
<span class="k">const</span><span class="w"> </span><span class="n">ROWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span>
<span class="k">const</span><span class="w"> </span><span class="n">COLS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span>
<span class="k">const</span><span class="w"> </span><span class="n">NSTEPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span>


<span class="s">&quot;&quot;&quot;</span>
<span class="s">    Field(nx::Int64, ny::Int64, dx::Float64, dy::Float64, data::Matrix{Float64})</span>

<span class="s">Temperature field type. nx and ny are the dimensions of the field. </span>
<span class="s">The array data contains also ghost layers, so it will have dimensions </span>
<span class="s">[nx+2, ny+2]</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">mutable</span><span class="w"> </span><span class="k">struct</span> <span class="kt">Field</span><span class="p">{</span><span class="kt">T</span><span class="o">&lt;:</span><span class="kt">AbstractArray</span><span class="p">}</span>
<span class="w">    </span><span class="n">nx</span><span class="o">::</span><span class="kt">Int64</span>
<span class="w">    </span><span class="n">ny</span><span class="o">::</span><span class="kt">Int64</span>
<span class="w">    </span><span class="c"># Size of the grid cells</span>
<span class="w">    </span><span class="n">dx</span><span class="o">::</span><span class="kt">Float64</span>
<span class="w">    </span><span class="n">dy</span><span class="o">::</span><span class="kt">Float64</span>
<span class="w">    </span><span class="c"># The temperature values in the 2D grid</span>
<span class="w">    </span><span class="n">data</span><span class="o">::</span><span class="kt">T</span>
<span class="k">end</span>

<span class="c"># outer constructor with default cell sizes and initialized data</span>
<span class="n">Field</span><span class="p">(</span><span class="n">nx</span><span class="o">::</span><span class="kt">Int64</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="o">::</span><span class="kt">Int64</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">Field</span><span class="p">{</span><span class="kt">typeof</span><span class="p">(</span><span class="kt">data</span><span class="p">)}(</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="mf">0.01</span><span class="p">,</span><span class="w"> </span><span class="mf">0.01</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="c"># extend deepcopy to new type</span>
<span class="n">Base</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">Field</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Field</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span><span class="w"> </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

<span class="s">&quot;&quot;&quot;</span>
<span class="s">    initialize(rows::Int, cols::Int, arraytype = Matrix)</span>

<span class="s">Initialize two temperature field with (nrows, ncols) number of </span>
<span class="s">rows and columns. If the arraytype is something else than Matrix,</span>
<span class="s">create data on the CPU first to avoid scalar indexing errors.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="w"> </span><span class="n">initialize</span><span class="p">(</span><span class="n">nrows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="n">ncols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="n">arraytype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">Matrix</span><span class="p">)</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ncols</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span><span class="c"># generate a field with boundary conditions</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">arraytype</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">Matrix</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Field</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="w"> </span><span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="w">        </span><span class="n">generate_field!</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="w">        </span><span class="n">gpudata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arraytype</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="w">        </span><span class="n">previous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Field</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="w"> </span><span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">gpudata</span><span class="p">)</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">previous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Field</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="w"> </span><span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="w">        </span><span class="n">generate_field!</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Base</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">current</span>
<span class="k">end</span>


<span class="s">&quot;&quot;&quot;</span>
<span class="s">    generate_field!(field0::Field)</span>

<span class="s">Generate a temperature field.  Pattern is disc with a radius</span>
<span class="s">of nx / 6 in the center of the grid. Boundary conditions are </span>
<span class="s">(different) constant temperatures outside the grid.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="w"> </span><span class="n">generate_field!</span><span class="p">(</span><span class="n">field</span><span class="o">::</span><span class="kt">Field</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Square of the disk radius</span>
<span class="w">    </span><span class="n">radius2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">nx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">6.0</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">field</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">2</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">field</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span>
<span class="w">            </span><span class="n">ds2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">field</span><span class="o">.</span><span class="n">nx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">field</span><span class="o">.</span><span class="n">ny</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">ds2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">radius2</span><span class="w"> </span>
<span class="w">                </span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T_DISC</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T_AREA</span>
<span class="w">            </span><span class="k">end</span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span>

<span class="w">    </span><span class="c"># Boundary conditions</span>
<span class="w">    </span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">T_LEFT</span>
<span class="w">    </span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">T_RIGHT</span>
<span class="w">    </span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">T_UPPER</span>
<span class="w">    </span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">T_LOWER</span>
<span class="k">end</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-6-6-3" class="sphinx-tabs-panel" hidden="true" id="panel-6-6-3" name="6-3" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">deps</span><span class="p">]</span>
<span class="n">BenchmarkTools</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf&quot;</span>
<span class="c">#Plots = &quot;91a5bcdd-55d7-5caf-9e0b-520d859cae80&quot;</span>
<span class="n">ProgressMeter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;92933f4c-e287-5a05-a399-4b506db050ca&quot;</span>
</pre></div>
</div>
</div></div>
<div class="admonition-exercise-julia-port-to-gpus exercise important admonition" id="exercise-6">
<p class="admonition-title">Exercise: Julia port to GPUs</p>
<p>Carefully inspect all Julia source files and consider the following questions:</p>
<ol class="arabic simple">
<li><p>Which functions should be ported to run on GPU?</p></li>
<li><p>Look at the <code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize!()</span></code> function and how it uses the <code class="docutils literal notranslate"><span class="pre">arraytype</span></code> argument. This could be done more compactly and elegantly, but this solution solves scalar indexing errors. What are scalar indexing errors?</p></li>
<li><p>Try to start sketching GPU-ported versions of the key functions.</p></li>
<li><p>When you have a version running on a GPU (your own or the solution provided below), try benchmarking it by adding <code class="docutils literal notranslate"><span class="pre">&#64;btime</span></code> in front of <code class="xref py py-meth docutils literal notranslate"><span class="pre">simulate!()</span></code> in <code class="docutils literal notranslate"><span class="pre">main.jl</span></code>. Benchmark also the CPU version, and compare.</p></li>
</ol>
<div class="admonition-hints solution important dropdown admonition" id="solution-8">
<p class="admonition-title">Hints</p>
<ul class="simple">
<li><p>create a new function <code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_gpu!()</span></code> which contains the GPU kernelized version of <code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve!()</span></code></p></li>
<li><p>in the loop over timesteps in <code class="xref py py-meth docutils literal notranslate"><span class="pre">simulate!()</span></code>, you will need a conditional like <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">typeof(curr.data)</span> <span class="pre">&lt;:</span> <span class="pre">ROCArray</span></code> to call your GPU-ported function</p></li>
<li><p>you cannot pass the struct <code class="docutils literal notranslate"><span class="pre">Field</span></code> to the kernel. You will instead need to directly pass the array <code class="docutils literal notranslate"><span class="pre">Field.data</span></code>. This also necessitates passing in other variables like <code class="docutils literal notranslate"><span class="pre">curr.dx^2</span></code>, etc.</p></li>
</ul>
</div>
<div class="admonition-more-hints solution important dropdown admonition" id="solution-9">
<p class="admonition-title">More hints</p>
<ul class="simple">
<li><p>since the data is two-dimensional, you’ll need <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">(blockIdx().x</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">blockDim().x</span> <span class="pre">+</span> <span class="pre">threadIdx().x</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">(blockIdx().y</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">blockDim().y</span> <span class="pre">+</span> <span class="pre">threadIdx().y</span></code></p></li>
<li><p>to not overindex the 2D array, you can use a conditional like <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">1</span> <span class="pre">&amp;&amp;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">nx+2</span> <span class="pre">&amp;&amp;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">ny+2</span></code></p></li>
<li><p>when calling the kernel, you can set the number of threads and blocks like <code class="docutils literal notranslate"><span class="pre">xthreads</span> <span class="pre">=</span> <span class="pre">ythreads</span> <span class="pre">=</span> <span class="pre">16</span></code> and <code class="docutils literal notranslate"><span class="pre">xblocks,</span> <span class="pre">yblocks</span> <span class="pre">=</span> <span class="pre">cld(curr.nx,</span> <span class="pre">xthreads),</span> <span class="pre">cld(curr.ny,</span> <span class="pre">ythreads)</span></code>, and then call it with, e.g., <code class="docutils literal notranslate"><span class="pre">&#64;roc</span> <span class="pre">threads=(xthreads,</span> <span class="pre">ythreads)</span> <span class="pre">blocks</span> <span class="pre">=</span> <span class="pre">(xblocks,</span> <span class="pre">yblocks)</span> <span class="pre">evolve_rocm!(curr.data,</span> <span class="pre">prev.data,</span> <span class="pre">curr.dx^2,</span> <span class="pre">curr.dy^2,</span> <span class="pre">nx,</span> <span class="pre">ny,</span> <span class="pre">a,</span> <span class="pre">dt)</span></code>.</p></li>
</ul>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-10">
<p class="admonition-title">Solution</p>
<ol class="arabic simple">
<li><p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve!()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">simulate!()</span></code> functions need to be ported. The <code class="docutils literal notranslate"><span class="pre">main.jl</span></code> file also needs to be updated to work with GPU arrays.</p></li>
<li><p>“Scalar indexing” is where you iterate over a GPU array, which would be excruciatingly slow and is indeed only allowed in interactive REPL sessions. Without the if-statements in the <code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize!()</span></code> function, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_field!()</span></code> method would be doing disallowed scalar indexing if you were running on a GPU.</p></li>
<li><p>The GPU-ported version is found below. Try it out on both CPU and GPU and observe the speedup. Play around with array size to see if the speedup is affected. You can also play around with the <code class="docutils literal notranslate"><span class="pre">xthreads</span></code> and <code class="docutils literal notranslate"><span class="pre">ythreads</span></code> variables to see if it changes anything.</p></li>
</ol>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-7-7-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-7-7-0" name="7-0" role="tab" tabindex="0">main_gpu.jl</button><button aria-controls="panel-7-7-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-7-7-1" name="7-1" role="tab" tabindex="-1">core_gpu.jl</button></div><div aria-labelledby="tab-7-7-0" class="sphinx-tabs-panel" id="panel-7-7-0" name="7-0" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c">#using Plots</span>
<span class="k">using</span><span class="w"> </span><span class="n">BenchmarkTools</span>
<span class="k">using</span><span class="w"> </span><span class="n">AMDGPU</span>

<span class="n">include</span><span class="p">(</span><span class="s">&quot;heat.jl&quot;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s">&quot;core_gpu.jl&quot;</span><span class="p">)</span>


<span class="s">&quot;&quot;&quot;</span>
<span class="s">    visualize(curr::Field, filename=:none)</span>

<span class="s">Create a heatmap of a temperature field. Optionally write png file. </span>
<span class="s">&quot;&quot;&quot;</span><span class="w">    </span>
<span class="k">function</span><span class="w"> </span><span class="n">visualize</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="o">=</span><span class="ss">:none</span><span class="p">)</span>
<span class="w">    </span><span class="n">background_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:white</span>
<span class="w">    </span><span class="n">plot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heatmap</span><span class="p">(</span>
<span class="w">        </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
<span class="w">        </span><span class="n">colorbar_title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Temperature (C)&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">background_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">background_color</span>
<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="ss">:none</span>
<span class="w">        </span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">display</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>


<span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">nrows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2048</span><span class="p">,</span><span class="w"> </span><span class="mi">2048</span>
<span class="n">nsteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span>

<span class="c"># initialize data on CPU</span>
<span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize</span><span class="p">(</span><span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="n">nrows</span><span class="p">,</span><span class="w"> </span><span class="n">ROCArray</span><span class="p">)</span>
<span class="c"># initialize data on CPU</span>
<span class="c">#curr, prev = initialize(ncols, nrows)</span>

<span class="c"># visualize initial field, requires Plots.jl</span>
<span class="c">#visualize(curr, &quot;initial.png&quot;)</span>

<span class="c"># simulate temperature evolution for nsteps</span>
<span class="nd">@btime</span><span class="w"> </span><span class="n">simulate!</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">nsteps</span><span class="p">)</span>

<span class="c"># visualize final field, requires Plots.jl</span>
<span class="c">#visualize(curr, &quot;final.png&quot;)</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-7-7-1" class="sphinx-tabs-panel" hidden="true" id="panel-7-7-1" name="7-1" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ProgressMeter</span>

<span class="s">&quot;&quot;&quot;</span>
<span class="s">    evolve!(curr::Field, prev::Field, a, dt)</span>

<span class="s">Calculate a new temperature field curr based on the previous </span>
<span class="s">field prev. a is the diffusion constant and dt is the largest </span>
<span class="s">stable time step.    </span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="w"> </span><span class="n">evolve!</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="w">    </span><span class="n">Threads</span><span class="o">.</span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">curr</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">curr</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">xderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">yderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">xderiv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yderiv</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>


<span class="k">function</span><span class="w"> </span><span class="n">evolve_cuda!</span><span class="p">(</span><span class="n">currdata</span><span class="p">,</span><span class="w"> </span><span class="n">prevdata</span><span class="p">,</span><span class="w"> </span><span class="n">dx2</span><span class="p">,</span><span class="w"> </span><span class="n">dy2</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">blockIdx</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
<span class="w">    </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">blockIdx</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">()</span><span class="o">.</span><span class="n">y</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="o">+</span><span class="mi">2</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">xderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">yderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">currdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">xderiv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yderiv</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span>
<span class="k">end</span>

<span class="k">function</span><span class="w"> </span><span class="n">evolve_rocm!</span><span class="p">(</span><span class="n">currdata</span><span class="p">,</span><span class="w"> </span><span class="n">prevdata</span><span class="p">,</span><span class="w"> </span><span class="n">dx2</span><span class="p">,</span><span class="w"> </span><span class="n">dy2</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">workgroupIdx</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">workgroupDim</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">workitemIdx</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
<span class="w">    </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">workgroupIdx</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">workgroupDim</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">workitemIdx</span><span class="p">()</span><span class="o">.</span><span class="n">y</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="o">+</span><span class="mi">2</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">xderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">yderiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">currdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">xderiv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yderiv</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span>
<span class="k">end</span>


<span class="s">&quot;&quot;&quot;</span>
<span class="s">    swap_fields!(curr::Field, prev::Field)</span>

<span class="s">Swap the data of two fields curr and prev.    </span>
<span class="s">&quot;&quot;&quot;</span><span class="w">    </span>
<span class="k">function</span><span class="w"> </span><span class="n">swap_fields!</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">::</span><span class="kt">Field</span><span class="p">)</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span>
<span class="w">    </span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span>
<span class="w">    </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span>
<span class="k">end</span>

<span class="s">&quot;&quot;&quot; </span>
<span class="s">    average_temperature(f::Field)</span>

<span class="s">Calculate average temperature of a temperature field.        </span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">average_temperature</span><span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="kt">Field</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>

<span class="s">&quot;&quot;&quot;</span>
<span class="s">    simulate!(current, previous, nsteps)</span>

<span class="s">Run the heat equation solver on fields curr and prev for nsteps.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="w"> </span><span class="n">simulate!</span><span class="p">(</span><span class="n">curr</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">::</span><span class="kt">Field</span><span class="p">,</span><span class="w"> </span><span class="n">nsteps</span><span class="p">)</span>

<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Initial average temperature: </span><span class="si">$</span><span class="p">(</span><span class="n">average_temperature</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span><span class="s">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Diffusion constant</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span>
<span class="w">    </span><span class="c"># Largest stable time step</span>
<span class="w">    </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span>
<span class="w">    </span>
<span class="w">    </span><span class="c"># display a nice progress bar</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Progress</span><span class="p">(</span><span class="n">nsteps</span><span class="p">)</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">nsteps</span>
<span class="w">        </span><span class="c"># calculate new state based on previous state</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">typeof</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">ROCArray</span>
<span class="w">            </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">.-</span><span class="w"> </span><span class="mi">2</span><span class="w">   </span>
<span class="w">            </span><span class="n">xthreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ythreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span>
<span class="w">            </span><span class="n">xblocks</span><span class="p">,</span><span class="w"> </span><span class="n">yblocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cld</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">xthreads</span><span class="p">),</span><span class="w"> </span><span class="n">cld</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">ythreads</span><span class="p">)</span>
<span class="w">            </span><span class="nd">@roc</span><span class="w"> </span><span class="n">threads</span><span class="o">=</span><span class="p">(</span><span class="n">xthreads</span><span class="p">,</span><span class="w"> </span><span class="n">ythreads</span><span class="p">)</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">xblocks</span><span class="p">,</span><span class="w"> </span><span class="n">yblocks</span><span class="p">)</span><span class="w"> </span><span class="n">evolve_rocm!</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span><span class="o">.</span><span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">evolve!</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># swap current and previous fields</span>
<span class="w">        </span><span class="n">swap_fields!</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">)</span>

<span class="w">        </span><span class="c"># increment the progress bar</span>
<span class="w">        </span><span class="n">next!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span>

<span class="w">    </span><span class="c"># print final average temperature</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Final average temperature: </span><span class="si">$</span><span class="p">(</span><span class="n">average_temperature</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
</div></div>
</div>
</div>
</section>
<section id="see-also">
<h2>See also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h2>
<p>This section leans heavily on source code and material created for several other
computing workshops by <a class="reference external" href="https://enccs.se/">ENCCS</a> and <a class="reference external" href="https://csc.fi/">CSC</a> and
adapted for the purposes of this lesson. If you want to know more about specific
programming models / framework, definitely check these out!</p>
<ul class="simple">
<li><p><a class="reference external" href="https://enccs.github.io/openmp-gpu/">OpenMP for GPU offloading</a></p></li>
<li><p><a class="reference external" href="https://enccs.github.io/sycl-workshop/">Heterogeneous programming with SYCL</a></p></li>
<li><p><a class="reference external" href="https://github.com/cschpc/heat-equation/">Educational implementation of heat flow example (incl. MPI-aware CUDA)</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../12-recommendations/" class="btn btn-neutral float-left" title="Recommendations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../quick-reference/" class="btn btn-neutral float-right" title="Quick Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2024, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>